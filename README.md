# Adofai_AutoCat 项目分析与 Python 重写

## 项目概述

Adofai_AutoCat 是一个为节奏游戏《冰与火之舞》（A Dance of Fire and Ice, 简称 Adofai）设计的自动化工具。它通过解析 Adofai 关卡文件（.adofai），模拟键盘输入，实现游戏的自动播放。该工具最初由 Java 语言开发，利用 JavaFX 构建用户界面，并使用 JNativeHook 库进行全局键盘事件监听，以实现启动/停止自动播放以及调整延迟的功能。

## 核心功能

该工具主要提供以下核心功能：

1.  **Adofai 关卡文件解析**：能够读取并解析 `.adofai` 格式的关卡文件，提取游戏中的关键事件信息，如每个瓦片的角度数据、BPM 变化、摇摆拍（Swing Rhythm）以及长按（Hold）事件。
2.  **自动播放逻辑**：根据解析出的关卡数据，计算每个瓦片或事件的精确时间点，并模拟键盘按键操作，实现游戏的自动进行。
3.  **全局热键控制**：通过设置全局热键（默认为 `Insert` 键），用户可以在游戏内外方便地启动或停止自动播放功能。
4.  **实时延迟调整**：在自动播放过程中，用户可以通过左右箭头键实时微调自动播放的延迟，以适应不同的游戏环境或个人偏好。
5.  **用户界面 (GUI)**：提供一个简洁的图形用户界面，允许用户选择 `.adofai` 关卡文件，并显示当前工具的状态（例如“运行中”）。

## 技术实现细节 (Java 版本)

原 Java 版本的 Adofai_AutoCat 项目主要由以下几个模块组成：

### 1. `Main.java` (主入口)

*   **功能**：应用程序的入口点，负责初始化 JavaFX 界面、设置主舞台（Stage）、加载 `main.fxml` 布局文件。
*   **全局键盘监听**：注册 `JNativeHook` 库的全局键盘监听器 `KeyDetect`，以便在应用程序外部也能捕获键盘事件。
*   **资源管理**：在应用程序关闭时，负责注销全局键盘钩子并中断自动播放线程，确保资源正确释放。
*   **错误处理**：包含一个 `getPrintStackTrace` 辅助方法，用于捕获并格式化异常堆栈信息。

### 2. `Controller.java` (GUI 控制器)

*   **功能**：作为 `main.fxml` 布局文件的控制器，处理用户界面的交互逻辑。
*   **文件选择**：通过 `FileChooser` 允许用户选择 `.adofai` 关卡文件，并显示已选择文件的名称。
*   **Adofai 对象管理**：当用户选择文件后，实例化 `Adofai` 类来解析关卡数据。如果解析失败，会弹出警告框。
*   **状态显示**：更新 GUI 上的标签，显示文件选择状态和自动播放状态。

### 3. `KeyDetect.java` (全局键盘事件检测)

*   **功能**：实现了 `NativeKeyListener` 接口，用于监听全局键盘按键事件。
*   **热键处理**：
    *   当检测到 `Insert` 键按下时，切换自动播放的启动/停止状态。在启动时，调用 `Adofai.start()`；在停止时，调用 `Adofai.cancel()`。
    *   当检测到左箭头键 (`Left Arrow`) 或右箭头键 (`Right Arrow`) 按下时，实时调整 `Adofai` 实例中的 `time` 变量，分别减少或增加 5 毫秒的延迟。这个调整仅在自动播放运行时有效。

### 4. `Adofai.java` (自动播放核心逻辑)

*   **功能**：负责解析关卡数据、计算按键时序，并执行模拟按键操作。
*   **构造函数**：接收关卡文件路径和用于显示状态的 `Label` 对象，内部通过 `LoadMap` 类解析关卡数据。
*   **`start()` 方法**：
    *   创建一个新的线程来执行自动播放逻辑，避免阻塞 GUI 线程。
    *   使用 `java.awt.Robot` 类模拟键盘按键（`keyPress` 和 `keyRelease`）。
    *   遍历 `delayList`（由 `LoadMap` 解析出的按键信息列表），根据计算出的延迟时间执行按键操作。
    *   **延迟校准**：`time` 变量用于全局延迟校准，可以通过 `KeyDetect` 中的左右箭头键进行实时调整。
    *   **初始延迟处理**：在首次启动时，会有一个特殊的初始延迟调整（`-150ms`），第二次启动时会进行补偿（`+150ms`）。这可能与游戏内的倒计时或加载时间有关。
    *   **按键释放逻辑**：对于每个按键，先按下，然后根据计算出的 `delay`（默认为 55 毫秒，长按事件有特定 `holdDelay`）后释放。这里使用了 `java.util.Timer` 和 `TimerTask` 来调度按键释放。
*   **`cancel()` 方法**：设置 `isCancel` 标志为 `true`，并中断自动播放线程，停止自动播放。

### 5. `LoadMap.java` (关卡文件解析)

*   **功能**：解析 `.adofai` 关卡文件，提取所有瓦片（Tile）的详细信息，并计算出每个按键操作的延迟时间。
*   **JSON 解析**：使用 `json-simple` 库解析 `.adofai` 文件（本质是 JSON 格式）。
*   **数据提取**：从 JSON 中提取 `angleData`、`bpm`、`speed` 事件、`hold` 事件等关键信息。
*   **延迟计算**：根据游戏逻辑（如角度、BPM、摇摆拍、长按）计算出每个按键操作相对于上一个操作的精确延迟时间（纳秒）。
*   **`PressInfo` 列表**：将计算出的延迟和对应的按键信息封装成 `PressInfo` 对象，存储在一个列表中供 `Adofai` 类使用。

### 6. `PressInfo.java`, `Angle.java`, `Key.java` (辅助类)

*   **`PressInfo.java`**：数据类，封装了单个按键操作的所有相关信息，包括延迟时间、按键代码、是否为长按以及长按持续时间等。
*   **`Angle.java`**：常量类，定义了 Adofai 游戏中各种角度对应的数值，用于辅助 `LoadMap` 解析 `angleData`。
*   **`Key.java`**：常量类，定义了常用的键盘按键代码，用于模拟按键操作。

## Python 重写计划

为了将 Adofai_AutoCat 移植到 Python，我们将遵循以下策略，并利用 Python 生态系统中相应的库来替代 Java 的功能：

### 1. GUI 界面

*   **替代方案**：使用 `Tkinter` 或 `PyQt` (如果需要更复杂的界面) 来构建图形用户界面。考虑到原 JavaFX 界面较为简洁，`Tkinter` 可能是更轻量级的选择。
*   **功能**：提供文件选择、状态显示（“运行中”）、以及可能的延迟数值显示。

### 2. 全局键盘事件监听

*   **替代方案**：使用 `pynput` 库。`pynput` 可以在 Windows、macOS 和 Linux 上监听和控制鼠标和键盘。
*   **功能**：实现 `Insert` 键的自动播放切换和左右箭头键的延迟调整。

### 3. Adofai 关卡文件解析与时间计算

*   **替代方案**：利用 `adofaipy` 库。这是一个专门为 Adofai 设计的 Python 库，能够精确解析 `.adofai` 文件，并处理复杂的 BPM 变化、摇摆拍和长按事件的时间计算。
*   **核心逻辑**：
    *   使用 `adofaipy.Level.load(file_path)` 加载关卡。
    *   利用 `level.get_duration_for_tile(tile_index)` 计算瓦片间的持续时间。
    *   利用 `level.get_duration_for_beats(hold_duration_beats, start_tile_index)` 计算长按事件的持续时间。
    *   这将替代原 Java 版本中 `LoadMap.java` 的大部分复杂逻辑，并确保时间计算的准确性。

### 4. 模拟键盘输入

*   **替代方案**：继续使用 `pynput` 库。它提供了 `Controller` 类来模拟键盘按键的按下和释放。
*   **功能**：根据 `adofaipy` 计算出的精确时间点，执行 `keyboard.press()` 和 `keyboard.release()` 操作。

### 5. 自动播放线程管理

*   **替代方案**：使用 Python 的 `threading` 模块来创建独立的线程运行自动播放逻辑，避免阻塞 GUI。
*   **功能**：实现启动、停止、中断线程的机制，与原 Java 版本的 `isCancel` 标志和 `thread.interrupt()` 类似。

### 6. 延迟校准与初始延迟

*   **校准**：保留 `time` 变量用于全局延迟校准，并通过 `pynput` 监听左右箭头键进行调整。
*   **初始延迟**：分析原 Java 代码中 `isFirst` 和 `isSecond` 标志对 `press.delay` 的特殊处理。这可能对应游戏启动时的倒计时（如“4, 3, 2, 1”）或加载时间。在 Python 版本中，需要确保正确模拟或补偿这部分延迟，可能通过 `adofaipy` 库提供的 `offset` 或在计算动作队列时手动添加。

## 开发环境与依赖 (Python 版本)

*   **Python 版本**：Python 3.x
*   **主要依赖**：
    *   `pynput`：用于全局键盘监听和模拟键盘输入。
    *   `adofaipy`：用于解析 `.adofai` 关卡文件和精确时间计算。
    *   `Tkinter` (Python 内置) 或 `PyQt5` (如果选择 PyQt) 用于 GUI。

可以通过 `pip` 安装所需库：

```bash
pip install pynput adofaipy
```

## 使用方法 (Python 版本)

1.  **运行程序**：执行 Python 脚本。
2.  **选择关卡文件**：在 GUI 界面中点击按钮选择 `.adofai` 关卡文件。
3.  **启动/停止**：在游戏内或游戏外按下 `Insert` 键，启动或停止自动播放。
4.  **调整延迟**：在自动播放过程中，按下左箭头键 (`Left Arrow`) 减少 5 毫秒延迟，按下右箭头键 (`Right Arrow`) 增加 5 毫秒延迟。

## 潜在的改进与未来工作

*   **更友好的延迟调整**：除了箭头键，可以在 GUI 中添加输入框或滑块来精确设置延迟。
*   **可视化反馈**：在 GUI 中显示当前延迟值，或者在游戏内通过某种方式（如 OSD）显示。
*   **多线程优化**：确保自动播放线程与 GUI 线程之间的通信和同步更加健壮。
*   **错误日志**：更详细的日志记录，方便调试和问题排查。
*   **配置保存**：保存用户选择的默认文件路径和延迟设置。
*   **支持更多事件**：如果 Adofai 游戏更新引入新的事件类型，需要更新 `adofaipy` 或手动扩展解析逻辑。
